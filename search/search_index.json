{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"LICENSE/","text":"MIT License Copyright \u00a9 2020 James Hooker Gearon & John Franey Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"LakePy/","text":"Lake __init__ ( self , name , country , continent , source , original_id , id_No , observation_period , latitude , longitude , misc_data , dataframe , data ) special Lake() constructor :param name: Lake name :type name: str :param country: Country of lake residence :type country: str :param continent: Continent of lake residence :type continent: str :param source: Original database of lake data :type source: str :param original_id: Original identifier of lake :type original_id: str :param id_No: GLLD identification number :type id_No: int :param observation_period: Range of water level data :type observation_period: str :param latitude: Decimal degree latitude :type latitude: str :param longitude: Decimal degree longitude :type longitude: str :param misc_data: Database-specific metadata :type misc_data: dict :param dataframe: Lake metadata as Pandas DataFrame :type dataframe: pandas.DataFrame() :param data: Lake water level timeseries data :type data: pandas.DataFrame() Source code in lakepy/main.py def __init__ ( self , name , country , continent , source , original_id , id_No , observation_period , latitude , longitude , misc_data , dataframe , data ): \"\"\" Lake() constructor :param name: Lake name :type name: str :param country: Country of lake residence :type country: str :param continent: Continent of lake residence :type continent: str :param source: Original database of lake data :type source: str :param original_id: Original identifier of lake :type original_id: str :param id_No: GLLD identification number :type id_No: int :param observation_period: Range of water level data :type observation_period: str :param latitude: Decimal degree latitude :type latitude: str :param longitude: Decimal degree longitude :type longitude: str :param misc_data: Database-specific metadata :type misc_data: dict :param dataframe: Lake metadata as Pandas DataFrame :type dataframe: pandas.DataFrame() :param data: Lake water level timeseries data :type data: pandas.DataFrame() \"\"\" self . name = name self . country = country self . continent = continent self . source = source self . original_id = original_id self . id_No = id_No self . observation_period = observation_period self . latitude = latitude self . longitude = longitude self . misc_data = misc_data self . dataframe = dataframe self . data = data plot_mapview ( self , show = True , out_path = None , zoom = None , return_gdf = False , * args , ** kwargs ) Plot map-style overview of lake location using geopandas as contextily :param show: Flag to determine whether matplotlib.pyplot.show() is called (True) or axis object is returned ( False) :type show: bool :param out_path: If supplied, figure will be saved to local filepath :type out_path: str :param args: additonal args to pass to matplotlib.pyplot axis :param kwargs: additonal *kwargs to pass to matplotlib.pyplot axis :return: matplotlib axis instance if :param show is False Source code in lakepy/main.py def plot_mapview ( self , show = True , out_path = None , zoom = None , return_gdf = False , * args , ** kwargs ): \"\"\" Plot map-style overview of lake location using geopandas as contextily :param show: Flag to determine whether matplotlib.pyplot.show() is called (True) or axis object is returned ( False) :type show: bool :param out_path: If supplied, figure will be saved to local filepath :type out_path: str :param args: additonal *args to pass to matplotlib.pyplot axis :param kwargs: additonal **kwargs to pass to matplotlib.pyplot axis :return: matplotlib axis instance if :param show is False \"\"\" import geopandas as gpd import contextily as ctx from shapely.geometry import Point import matplotlib.pyplot as plt gdf = gpd . GeoDataFrame ( self . dataframe , geometry = [ Point ( float ( self . longitude ), float ( self . latitude ))]) gdf . crs = 'EPSG:4326' fig , ax = plt . subplots ( 1 , 1 ) gdf . plot ( * args , ** kwargs , alpha =. 5 , ax = ax , color = 'red' , aspect = 'equal' ) if zoom : ctx . add_basemap ( ax , source = ctx . providers . OpenTopoMap , crs = 'EPSG:4326' , zoom = zoom ) else : ctx . add_basemap ( ax , source = ctx . providers . OpenTopoMap , crs = 'EPSG:4326' ) ax . set_title ( str ( self . id_No ) + \" : \" + self . name ) if out_path : plt . savefig ( out_path ) if show == True : plt . show () elif return_gdf == True : return gdf else : return ax plot_timeseries ( self , how = 'plotly' , color = 'blue' , show = True , date_start = None , date_end = None , * args , ** kwargs ) Plot timeseries of lake water level data :param how: what plotting package to use: \"plotly\", \"seaborn\" or \"matplotlib\" :type how: str :param color: color to plot timeseries with, must conform with selected package syntax :type color: str :param show: :type show: bool :param args: args to pass to matplotlib or seaborn axis :param kwargs: kwargs to pass to matplotlib or seaborn axis :return: matplotlib axis object, or None Source code in lakepy/main.py def plot_timeseries ( self , how = 'plotly' , color = \"blue\" , show = True , date_start = None , date_end = None , * args , ** kwargs ): \"\"\" Plot timeseries of lake water level data :param how: what plotting package to use: \"plotly\", \"seaborn\" or \"matplotlib\" :type how: str :param color: color to plot timeseries with, must conform with selected package syntax :type color: str :param show: :type show: bool :param args: args to pass to matplotlib or seaborn axis :param kwargs: kwargs to pass to matplotlib or seaborn axis :return: matplotlib axis object, or None \"\"\" import matplotlib.ticker as ticker import plotly.io as pio import plotly.express as px import seaborn as sns import pandas as pd import matplotlib.pyplot as plt import warnings from lakepy.utils import _validate if date_start and date_end : _validate ( date_start ) _validate ( date_end ) self . data . date = pd . to_datetime ( self . data . date ) self . data = self . data [( self . data [ 'date' ] > pd . Timestamp ( date_start )) & ( self . data [ 'date' ] < pd . Timestamp ( date_end ))] elif date_start is None and date_end is None : pass else : raise ValueError ( 'date_start and date_end params must both be None or strings with date format \"%Y-%m- %d \"' ) if how == 'plotly' : pio . renderers . default = \"browser\" plot = px . line ( self . data , x = 'date' , y = 'water_level' , title = str ( self . id_No ) + \": \" + self . name ) if color != \"blue\" : warnings . warn ( 'Cannot specify color for plotly style plots, use how = \"seaborn\" or \"matplotlib\" to ' 'pass color' , category = RuntimeWarning ) plot . update_xaxes ( rangeslider_visible = True , rangeselector = dict ( buttons = list ([ dict ( count = 1 , label = \"1m\" , step = \"month\" , stepmode = \"backward\" ), dict ( count = 6 , label = \"6m\" , step = \"month\" , stepmode = \"backward\" ), dict ( count = 1 , label = \"YTD\" , step = \"year\" , stepmode = \"todate\" ), dict ( count = 1 , label = \"1Y\" , step = \"year\" , stepmode = \"backward\" ), dict ( count = 5 , label = \"5Y\" , step = \"year\" , stepmode = \"backward\" ), dict ( count = 10 , label = \"10Y\" , step = \"year\" , stepmode = \"backward\" ), dict ( step = \"all\" ), ])), type = \"date\" ) plot . show () else : fig , ax = plt . subplots ( 1 , 1 ) ax . xaxis . set_major_locator ( ticker . AutoLocator ()) ax . set_title ( str ( self . id_No ) + \" : \" + self . name ) ax . set_ylabel ( 'Water Level [m]' ) ax . set_xlabel ( 'Date' ) if how == 'seaborn' : sns . set_style ( 'whitegrid' ) sns . lineplot ( data = self . data , x = \"date\" , y = \"water_level\" , ax = ax , color = color , * args , ** kwargs ) elif how == 'matplotlib' : ax . plot ( self . data . date , self . data . water_level , color = color , * args , ** kwargs ) plt . xticks ( rotation = 45 , ha = 'right' ) else : raise SyntaxError ( \"'how' parameter must be 'plotly', 'seaborn', or 'matplotlib'\" ) if show == True : plt . show () else : return ax search ( name = None , source = None , id_No = None ) Main search function for querying the Global Lake Level Database :param name: Name of Lake or Reservoir. Be sure to use proper spelling. Wildcards (%) are allowed, as is any MySQL 5.7 syntax :type name: str :param source: Lake water level source flag, accepted values are \"usgs\", \"grealm\", or \"hydroweb\" :type source: str :param id_No: Global Lake Level Database identification number, :type id_No: str :return: Lake() object Source code in lakepy/main.py def search ( name = None , source = None , id_No = None ): \"\"\" Main search function for querying the Global Lake Level Database :param name: Name of Lake or Reservoir. Be sure to use proper spelling. Wildcards (%) are allowed, as is any MySQL 5.7 syntax :type name: str :param source: Lake water level source flag, accepted values are \"usgs\", \"grealm\", or \"hydroweb\" :type source: str :param id_No: Global Lake Level Database identification number, :type id_No: str :return: Lake() object \"\"\" from sqlalchemy import create_engine from sqlalchemy import text import warnings import pandas as pd cluster_arn = 'arn:aws:rds:us-east-2:003707765429:cluster:esip-global-lake-level' secret_arn = 'arn:aws:secretsmanager:us-east-2:003707765429:secret:esip-lake-level-enduser-qugKfY' database = 'GlobalLakeLevel' if name : safe_name = text ( name ) if type ( id_No ) is int : id_No = str ( id_No ) sql_engine = create_engine ( 'mysql+pydataapi://' , connect_args = { 'resource_arn' : cluster_arn , 'secret_arn' : secret_arn , 'database' : database }, pool_pre_ping = True ) . connect () if id_No : df_lake = pd . read_sql ( 'select * from reference_ID where id_No = :id' , con = sql_engine , params = { 'id' : id_No }) elif source : df_lake = pd . read_sql ( 'select * from reference_ID where lake_name like :name and source like :source' , con = sql_engine , params = { 'name' : safe_name , 'source' : source }) else : df_lake = pd . read_sql ( 'SELECT * FROM reference_ID WHERE MATCH (lake_name) AGAINST (:name IN NATURAL LANGUAGE ' 'MODE) LIMIT 0, 5' , con = sql_engine , params = { 'name' : safe_name }) sql_engine . close () if len ( df_lake ) < 1 : raise RuntimeError ( 'No results returned. Please adjust search parameters or see documentation' ) if len ( df_lake ) > 1 : warnings . warn ( 'Search Result: \\' {} \\' has more than 1 Result. Showing the {} most relevant results. \\n ' 'Specify \\' id_No \\' or narrow search name.' . format ( safe_name , len ( df_lake )), category = RuntimeWarning ) print ( df_lake . filter ([ 'id_No' , 'source' , 'lake_name' ]) . to_markdown ()) elif len ( df_lake ) == 1 : meta_series = df_lake [ 'metadata' ] . map ( eval ) . apply ( pd . Series ) df_unpacked = pd . merge ( left = df_lake , right = meta_series . drop ([ 'source' , 'lake_name' ], axis = 1 ), left_index = True , right_index = True , how = 'outer' ) . drop ( 'metadata' , axis = 1 ) print ( df_unpacked . to_markdown ()) lake_object = _lake_meta_constructor ( df_unpacked ) return lake_object","title":"API Reference"},{"location":"LakePy/#lakepy.main","text":"","title":"lakepy.main"},{"location":"LakePy/#lakepy.main.Lake","text":"","title":"Lake"},{"location":"LakePy/#lakepy.main.Lake.__init__","text":"Lake() constructor :param name: Lake name :type name: str :param country: Country of lake residence :type country: str :param continent: Continent of lake residence :type continent: str :param source: Original database of lake data :type source: str :param original_id: Original identifier of lake :type original_id: str :param id_No: GLLD identification number :type id_No: int :param observation_period: Range of water level data :type observation_period: str :param latitude: Decimal degree latitude :type latitude: str :param longitude: Decimal degree longitude :type longitude: str :param misc_data: Database-specific metadata :type misc_data: dict :param dataframe: Lake metadata as Pandas DataFrame :type dataframe: pandas.DataFrame() :param data: Lake water level timeseries data :type data: pandas.DataFrame() Source code in lakepy/main.py def __init__ ( self , name , country , continent , source , original_id , id_No , observation_period , latitude , longitude , misc_data , dataframe , data ): \"\"\" Lake() constructor :param name: Lake name :type name: str :param country: Country of lake residence :type country: str :param continent: Continent of lake residence :type continent: str :param source: Original database of lake data :type source: str :param original_id: Original identifier of lake :type original_id: str :param id_No: GLLD identification number :type id_No: int :param observation_period: Range of water level data :type observation_period: str :param latitude: Decimal degree latitude :type latitude: str :param longitude: Decimal degree longitude :type longitude: str :param misc_data: Database-specific metadata :type misc_data: dict :param dataframe: Lake metadata as Pandas DataFrame :type dataframe: pandas.DataFrame() :param data: Lake water level timeseries data :type data: pandas.DataFrame() \"\"\" self . name = name self . country = country self . continent = continent self . source = source self . original_id = original_id self . id_No = id_No self . observation_period = observation_period self . latitude = latitude self . longitude = longitude self . misc_data = misc_data self . dataframe = dataframe self . data = data","title":"__init__()"},{"location":"LakePy/#lakepy.main.Lake.plot_mapview","text":"Plot map-style overview of lake location using geopandas as contextily :param show: Flag to determine whether matplotlib.pyplot.show() is called (True) or axis object is returned ( False) :type show: bool :param out_path: If supplied, figure will be saved to local filepath :type out_path: str :param args: additonal args to pass to matplotlib.pyplot axis :param kwargs: additonal *kwargs to pass to matplotlib.pyplot axis :return: matplotlib axis instance if :param show is False Source code in lakepy/main.py def plot_mapview ( self , show = True , out_path = None , zoom = None , return_gdf = False , * args , ** kwargs ): \"\"\" Plot map-style overview of lake location using geopandas as contextily :param show: Flag to determine whether matplotlib.pyplot.show() is called (True) or axis object is returned ( False) :type show: bool :param out_path: If supplied, figure will be saved to local filepath :type out_path: str :param args: additonal *args to pass to matplotlib.pyplot axis :param kwargs: additonal **kwargs to pass to matplotlib.pyplot axis :return: matplotlib axis instance if :param show is False \"\"\" import geopandas as gpd import contextily as ctx from shapely.geometry import Point import matplotlib.pyplot as plt gdf = gpd . GeoDataFrame ( self . dataframe , geometry = [ Point ( float ( self . longitude ), float ( self . latitude ))]) gdf . crs = 'EPSG:4326' fig , ax = plt . subplots ( 1 , 1 ) gdf . plot ( * args , ** kwargs , alpha =. 5 , ax = ax , color = 'red' , aspect = 'equal' ) if zoom : ctx . add_basemap ( ax , source = ctx . providers . OpenTopoMap , crs = 'EPSG:4326' , zoom = zoom ) else : ctx . add_basemap ( ax , source = ctx . providers . OpenTopoMap , crs = 'EPSG:4326' ) ax . set_title ( str ( self . id_No ) + \" : \" + self . name ) if out_path : plt . savefig ( out_path ) if show == True : plt . show () elif return_gdf == True : return gdf else : return ax","title":"plot_mapview()"},{"location":"LakePy/#lakepy.main.Lake.plot_timeseries","text":"Plot timeseries of lake water level data :param how: what plotting package to use: \"plotly\", \"seaborn\" or \"matplotlib\" :type how: str :param color: color to plot timeseries with, must conform with selected package syntax :type color: str :param show: :type show: bool :param args: args to pass to matplotlib or seaborn axis :param kwargs: kwargs to pass to matplotlib or seaborn axis :return: matplotlib axis object, or None Source code in lakepy/main.py def plot_timeseries ( self , how = 'plotly' , color = \"blue\" , show = True , date_start = None , date_end = None , * args , ** kwargs ): \"\"\" Plot timeseries of lake water level data :param how: what plotting package to use: \"plotly\", \"seaborn\" or \"matplotlib\" :type how: str :param color: color to plot timeseries with, must conform with selected package syntax :type color: str :param show: :type show: bool :param args: args to pass to matplotlib or seaborn axis :param kwargs: kwargs to pass to matplotlib or seaborn axis :return: matplotlib axis object, or None \"\"\" import matplotlib.ticker as ticker import plotly.io as pio import plotly.express as px import seaborn as sns import pandas as pd import matplotlib.pyplot as plt import warnings from lakepy.utils import _validate if date_start and date_end : _validate ( date_start ) _validate ( date_end ) self . data . date = pd . to_datetime ( self . data . date ) self . data = self . data [( self . data [ 'date' ] > pd . Timestamp ( date_start )) & ( self . data [ 'date' ] < pd . Timestamp ( date_end ))] elif date_start is None and date_end is None : pass else : raise ValueError ( 'date_start and date_end params must both be None or strings with date format \"%Y-%m- %d \"' ) if how == 'plotly' : pio . renderers . default = \"browser\" plot = px . line ( self . data , x = 'date' , y = 'water_level' , title = str ( self . id_No ) + \": \" + self . name ) if color != \"blue\" : warnings . warn ( 'Cannot specify color for plotly style plots, use how = \"seaborn\" or \"matplotlib\" to ' 'pass color' , category = RuntimeWarning ) plot . update_xaxes ( rangeslider_visible = True , rangeselector = dict ( buttons = list ([ dict ( count = 1 , label = \"1m\" , step = \"month\" , stepmode = \"backward\" ), dict ( count = 6 , label = \"6m\" , step = \"month\" , stepmode = \"backward\" ), dict ( count = 1 , label = \"YTD\" , step = \"year\" , stepmode = \"todate\" ), dict ( count = 1 , label = \"1Y\" , step = \"year\" , stepmode = \"backward\" ), dict ( count = 5 , label = \"5Y\" , step = \"year\" , stepmode = \"backward\" ), dict ( count = 10 , label = \"10Y\" , step = \"year\" , stepmode = \"backward\" ), dict ( step = \"all\" ), ])), type = \"date\" ) plot . show () else : fig , ax = plt . subplots ( 1 , 1 ) ax . xaxis . set_major_locator ( ticker . AutoLocator ()) ax . set_title ( str ( self . id_No ) + \" : \" + self . name ) ax . set_ylabel ( 'Water Level [m]' ) ax . set_xlabel ( 'Date' ) if how == 'seaborn' : sns . set_style ( 'whitegrid' ) sns . lineplot ( data = self . data , x = \"date\" , y = \"water_level\" , ax = ax , color = color , * args , ** kwargs ) elif how == 'matplotlib' : ax . plot ( self . data . date , self . data . water_level , color = color , * args , ** kwargs ) plt . xticks ( rotation = 45 , ha = 'right' ) else : raise SyntaxError ( \"'how' parameter must be 'plotly', 'seaborn', or 'matplotlib'\" ) if show == True : plt . show () else : return ax","title":"plot_timeseries()"},{"location":"LakePy/#lakepy.main.search","text":"Main search function for querying the Global Lake Level Database :param name: Name of Lake or Reservoir. Be sure to use proper spelling. Wildcards (%) are allowed, as is any MySQL 5.7 syntax :type name: str :param source: Lake water level source flag, accepted values are \"usgs\", \"grealm\", or \"hydroweb\" :type source: str :param id_No: Global Lake Level Database identification number, :type id_No: str :return: Lake() object Source code in lakepy/main.py def search ( name = None , source = None , id_No = None ): \"\"\" Main search function for querying the Global Lake Level Database :param name: Name of Lake or Reservoir. Be sure to use proper spelling. Wildcards (%) are allowed, as is any MySQL 5.7 syntax :type name: str :param source: Lake water level source flag, accepted values are \"usgs\", \"grealm\", or \"hydroweb\" :type source: str :param id_No: Global Lake Level Database identification number, :type id_No: str :return: Lake() object \"\"\" from sqlalchemy import create_engine from sqlalchemy import text import warnings import pandas as pd cluster_arn = 'arn:aws:rds:us-east-2:003707765429:cluster:esip-global-lake-level' secret_arn = 'arn:aws:secretsmanager:us-east-2:003707765429:secret:esip-lake-level-enduser-qugKfY' database = 'GlobalLakeLevel' if name : safe_name = text ( name ) if type ( id_No ) is int : id_No = str ( id_No ) sql_engine = create_engine ( 'mysql+pydataapi://' , connect_args = { 'resource_arn' : cluster_arn , 'secret_arn' : secret_arn , 'database' : database }, pool_pre_ping = True ) . connect () if id_No : df_lake = pd . read_sql ( 'select * from reference_ID where id_No = :id' , con = sql_engine , params = { 'id' : id_No }) elif source : df_lake = pd . read_sql ( 'select * from reference_ID where lake_name like :name and source like :source' , con = sql_engine , params = { 'name' : safe_name , 'source' : source }) else : df_lake = pd . read_sql ( 'SELECT * FROM reference_ID WHERE MATCH (lake_name) AGAINST (:name IN NATURAL LANGUAGE ' 'MODE) LIMIT 0, 5' , con = sql_engine , params = { 'name' : safe_name }) sql_engine . close () if len ( df_lake ) < 1 : raise RuntimeError ( 'No results returned. Please adjust search parameters or see documentation' ) if len ( df_lake ) > 1 : warnings . warn ( 'Search Result: \\' {} \\' has more than 1 Result. Showing the {} most relevant results. \\n ' 'Specify \\' id_No \\' or narrow search name.' . format ( safe_name , len ( df_lake )), category = RuntimeWarning ) print ( df_lake . filter ([ 'id_No' , 'source' , 'lake_name' ]) . to_markdown ()) elif len ( df_lake ) == 1 : meta_series = df_lake [ 'metadata' ] . map ( eval ) . apply ( pd . Series ) df_unpacked = pd . merge ( left = df_lake , right = meta_series . drop ([ 'source' , 'lake_name' ], axis = 1 ), left_index = True , right_index = True , how = 'outer' ) . drop ( 'metadata' , axis = 1 ) print ( df_unpacked . to_markdown ()) lake_object = _lake_meta_constructor ( df_unpacked ) return lake_object","title":"search()"},{"location":"contributing/","text":":construction: This page is a work in progress :construction: How to Contribute Hi! Thank you for looking into how to contribute. The following is a guideline on how to contribute towards: Bug Reports Bug Patches New Features New Databases Bug Reports Ensure the bug has not already been reported in our issues . If the bug has not been reported, please feel free to open a new issue . In the new issue, please include a title and clear description of the bug. Also include as much relevant information as possible, a code example that caused the bug, and the error warning . Bug Patches Open a pull request with the patch. Fully describe the problem the patch is meant to fix. It would also be helpful to link to the relevant issue . New Features if you have an idea for new methods to be added to the Lake() class, we would love to hear them! The current state of LakePy mainly deals with accessing the actual lake level data from the disparate data sources that have been collated to our AWS MySQL database. However, it would always be great to give more options and methods to our users. We are sure many of you have great ideas on how this data can be used in ways we never thought of! We currently use issues and PR for bug patches. if you have an idea about a new feature please send a description and code example to lakepygithub@gmail.com . After discussions, revisions, and approval, feel free to open a new pull request with the same title. New Databases Adding new lakes to our database is possibly the most helpful thing to this project. We currently source our data from: United States Geological Survey National Water Information System United States Department of Agriculture: Foriegn Agricultural Service's G-REALM Database Theia's HydroWeb Database These are currently some of the largest lake databases, but no database is too big or small for our project! Whether a a new lake data is a country, state, or county, if it is public data, we would love to add it to LakePy. First, please do check to make sure the lakes you wish to add are not already a part of LakePy. Adding a new data source is fairly resource intensive and occurs on our backend. Please reach out to us at lakepygithub@gmail.com to get started on adding a new data source. We appreciate taking the time to look into how to contribute towards LakePy. Thanks, James Gearon & John Franey LakePy is Funded by the Earth Science Information Partners (ESIP) Winter 2020 Grant. See the funded proposal here .","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"Hi! Thank you for looking into how to contribute. The following is a guideline on how to contribute towards: Bug Reports Bug Patches New Features New Databases","title":"How to Contribute"},{"location":"contributing/#bug-reports","text":"Ensure the bug has not already been reported in our issues . If the bug has not been reported, please feel free to open a new issue . In the new issue, please include a title and clear description of the bug. Also include as much relevant information as possible, a code example that caused the bug, and the error warning .","title":"Bug Reports"},{"location":"contributing/#bug-patches","text":"Open a pull request with the patch. Fully describe the problem the patch is meant to fix. It would also be helpful to link to the relevant issue .","title":"Bug Patches"},{"location":"contributing/#new-features","text":"if you have an idea for new methods to be added to the Lake() class, we would love to hear them! The current state of LakePy mainly deals with accessing the actual lake level data from the disparate data sources that have been collated to our AWS MySQL database. However, it would always be great to give more options and methods to our users. We are sure many of you have great ideas on how this data can be used in ways we never thought of! We currently use issues and PR for bug patches. if you have an idea about a new feature please send a description and code example to lakepygithub@gmail.com . After discussions, revisions, and approval, feel free to open a new pull request with the same title.","title":"New Features"},{"location":"contributing/#new-databases","text":"Adding new lakes to our database is possibly the most helpful thing to this project. We currently source our data from: United States Geological Survey National Water Information System United States Department of Agriculture: Foriegn Agricultural Service's G-REALM Database Theia's HydroWeb Database These are currently some of the largest lake databases, but no database is too big or small for our project! Whether a a new lake data is a country, state, or county, if it is public data, we would love to add it to LakePy. First, please do check to make sure the lakes you wish to add are not already a part of LakePy. Adding a new data source is fairly resource intensive and occurs on our backend. Please reach out to us at lakepygithub@gmail.com to get started on adding a new data source. We appreciate taking the time to look into how to contribute towards LakePy. Thanks, James Gearon & John Franey LakePy is Funded by the Earth Science Information Partners (ESIP) Winter 2020 Grant. See the funded proposal here .","title":"New Databases"},{"location":"docs_README/","text":"LakePy LakePy is the pythonic user-centered front-end to the Global Lake Level Database . This package can instantly deliver lake water levels for some 2000+ lakes scattered across the globe. Data comes from three sources (so far!) - United States Geological Survey National Water Information System - United States Department of Agriculture: Foriegn Agricultural Service's G-REALM Database - Theia's HydroWeb Database Funding for this work comes from the Earth Science Information Partners (ESIP) Winter 2020 Grant See the funded proposal here Motivation Lake level data is incredibly important to federal and local governments, scientists, and citizens. Until now, accessing lake level data involves laborious data-preparation and wrangling. We aim to provide this data quickly and on-demand. Software Used Built with - Python - Amazon Aurora Serverless - Amazon Aurora Serverless Data API Quickstart Installation pip install lakepy if you are using conda for package management you can still use pip! ### Searching the Global Lake Level Database The database can be searched using a name, a source (\"grealm\", \"hydroweb\", or \"usgs\"), or an identification number . The best practice for searching is to first specify a name. Let's search for Lake Mead instantiating a Lake() object. import lakepy as lk my_lake = lk.search(\"mead\") If there is more than one Lake matching \"Mead\", the search function will return a RuntimeWarning and display a table. \"Search Result: 'Mead' has more than 1 Result. Showing the 2 most relevant results. Specify 'id_No' or narrow search name.\" id_No source lake_name 0 138 hydroweb Mead 1 1556 usgs MEAD LAKE WEST BAY NEAR WILLARD, WI We will select id_No 138 corresponding to Lake Mead from HydroWeb's database and re-run our search 1 of 2 ways: - Specify the id_No explicitly as a string my_lake = lk.search(id_No = \"138\") Specify a name and a source my_lake = lk.search(name=\"mead\", source=\"hydroweb\", markdown=True) We highly recommend specifying an id_No whenever possible to avoid issues with similarly named lakes. Either way , the search returns a metadata markdown dataframe id_No source lake_name basin status country end_date latitude longitude identifier start_date 0 138 hydroweb Mead Colorado research USA 2014-12-29 00:21 36.13 -114.45 L_mead 2000-06-14 10:22 It is important to note that different databases will return different types and amounts of metadata. Currently latitude & longitude are only available from the USGS and HydroWeb databases, but GREALM lakes will soon have them! ### Lake() object The \"my_lake\" variable is now an object of class Lake() which comes with several attributes name country continent (currently not supported for HydroWeb) source original_id id_No observation_period latitude (currently not supported for G-REALM) longitude (currently not supported for G-REALM) misc_data dataframe data importantly, my_lake.dataframe and my_lake.data are pandas dataframe instances with associated methods my_lake.dataframe.describe().to_markdown() water_level count 119 mean 342.807 std 7.34547 min 330.75 25% 337.905 50% 342.26 75% 347.555 max 365.43 Plotting LakePy allows for native time series plotting as well as map-view plots my_lake.plot_timeseries() Plotly (default) Seaborn/Matplotlib my_lake.plot_timeseries(how='seaborn') my_lake.plot_mapview() Contributing We would love your help in making this project better. Please refer to our contribution guide to learn how. Credits This work is based on funding provided by the ESIP Lab with support from the National Aeronautics and Space Administration (NASA), National Oceanic and Atmospheric Administration (NOAA) and the United States Geologic Survey (USGS). The authors would also like to acknowledge the Dynamic Stratigraphy Group at UT Austin and the AWS Staff that helped on this project! License MIT \u00a9 James Hooker Gearon & John Franey","title":"Home"},{"location":"docs_README/#lakepy","text":"LakePy is the pythonic user-centered front-end to the Global Lake Level Database . This package can instantly deliver lake water levels for some 2000+ lakes scattered across the globe. Data comes from three sources (so far!) - United States Geological Survey National Water Information System - United States Department of Agriculture: Foriegn Agricultural Service's G-REALM Database - Theia's HydroWeb Database Funding for this work comes from the Earth Science Information Partners (ESIP) Winter 2020 Grant See the funded proposal here","title":"LakePy"},{"location":"docs_README/#motivation","text":"Lake level data is incredibly important to federal and local governments, scientists, and citizens. Until now, accessing lake level data involves laborious data-preparation and wrangling. We aim to provide this data quickly and on-demand.","title":"Motivation"},{"location":"docs_README/#software-used","text":"Built with - Python - Amazon Aurora Serverless - Amazon Aurora Serverless Data API","title":"Software Used"},{"location":"docs_README/#quickstart","text":"","title":"Quickstart"},{"location":"docs_README/#installation","text":"pip install lakepy if you are using conda for package management you can still use pip! ### Searching the Global Lake Level Database The database can be searched using a name, a source (\"grealm\", \"hydroweb\", or \"usgs\"), or an identification number . The best practice for searching is to first specify a name. Let's search for Lake Mead instantiating a Lake() object. import lakepy as lk my_lake = lk.search(\"mead\") If there is more than one Lake matching \"Mead\", the search function will return a RuntimeWarning and display a table. \"Search Result: 'Mead' has more than 1 Result. Showing the 2 most relevant results. Specify 'id_No' or narrow search name.\" id_No source lake_name 0 138 hydroweb Mead 1 1556 usgs MEAD LAKE WEST BAY NEAR WILLARD, WI We will select id_No 138 corresponding to Lake Mead from HydroWeb's database and re-run our search 1 of 2 ways: - Specify the id_No explicitly as a string my_lake = lk.search(id_No = \"138\") Specify a name and a source my_lake = lk.search(name=\"mead\", source=\"hydroweb\", markdown=True) We highly recommend specifying an id_No whenever possible to avoid issues with similarly named lakes. Either way , the search returns a metadata markdown dataframe id_No source lake_name basin status country end_date latitude longitude identifier start_date 0 138 hydroweb Mead Colorado research USA 2014-12-29 00:21 36.13 -114.45 L_mead 2000-06-14 10:22 It is important to note that different databases will return different types and amounts of metadata. Currently latitude & longitude are only available from the USGS and HydroWeb databases, but GREALM lakes will soon have them! ### Lake() object The \"my_lake\" variable is now an object of class Lake() which comes with several attributes name country continent (currently not supported for HydroWeb) source original_id id_No observation_period latitude (currently not supported for G-REALM) longitude (currently not supported for G-REALM) misc_data dataframe data importantly, my_lake.dataframe and my_lake.data are pandas dataframe instances with associated methods my_lake.dataframe.describe().to_markdown() water_level count 119 mean 342.807 std 7.34547 min 330.75 25% 337.905 50% 342.26 75% 347.555 max 365.43","title":"Installation"},{"location":"docs_README/#plotting","text":"LakePy allows for native time series plotting as well as map-view plots my_lake.plot_timeseries() Plotly (default) Seaborn/Matplotlib my_lake.plot_timeseries(how='seaborn')","title":"Plotting"},{"location":"docs_README/#_1","text":"my_lake.plot_mapview()","title":""},{"location":"docs_README/#contributing","text":"We would love your help in making this project better. Please refer to our contribution guide to learn how.","title":"Contributing"},{"location":"docs_README/#credits","text":"This work is based on funding provided by the ESIP Lab with support from the National Aeronautics and Space Administration (NASA), National Oceanic and Atmospheric Administration (NOAA) and the United States Geologic Survey (USGS). The authors would also like to acknowledge the Dynamic Stratigraphy Group at UT Austin and the AWS Staff that helped on this project!","title":"Credits"},{"location":"docs_README/#license","text":"MIT \u00a9 James Hooker Gearon & John Franey","title":"License"},{"location":"resources/contributing/","text":":construction: This page is a work in progress :construction: How to Contribute Hi! Thank you for looking into how to contribute. The following is a guideline on how to contribute towards: Bug Reports Bug Patches New Features New Databases Bug Reports Ensure the bug has not already been reported in our issues . If the bug has not been reported, please feel free to open a new issue . In the new issue, please include a title and clear description of the bug. Also include as much relevant information as possible, a code example that caused the bug, and the error warning . Bug Patches Open a pull request with the patch. Fully describe the problem the patch is meant to fix. It would also be helpful to link to the relevant issue . New Features if you have an idea for new methods to be added to the Lake() class, we would love to hear them! The current state of LakePy mainly deals with accessing the actual lake level data from the disparate data sources that have been collated to our AWS MySQL database. However, it would always be great to give more options and methods to our users. We are sure many of you have great ideas on how this data can be used in ways we never thought of! We currently use issues and PR for bug patches. if you have an idea about a new feature please send a description and code example to lakepygithub@gmail.com . After discussions, revisions, and approval, feel free to open a new pull request with the same title. New Databases Adding new lakes to our database is possibly the most helpful thing to this project. We currently source our data from: United States Geological Survey National Water Information System United States Department of Agriculture: Foriegn Agricultural Service's G-REALM Database Theia's HydroWeb Database These are currently some of the largest lake databases, but no database is too big or small for our project! Whether a a new lake data is a country, state, or county, if it is public data, we would love to add it to LakePy. First, please do check to make sure the lakes you wish to add are not already a part of LakePy. Adding a new data source is fairly resource intensive and occurs on our backend. Please reach out to us at lakepygithub@gmail.com to get started on adding a new data source. We appreciate taking the time to look into how to contribute towards LakePy. Thanks, James Gearon & John Franey LakePy is Funded by the Earth Science Information Partners (ESIP) Winter 2020 Grant. See the funded proposal here .","title":"Contributing"},{"location":"resources/contributing/#how-to-contribute","text":"Hi! Thank you for looking into how to contribute. The following is a guideline on how to contribute towards: Bug Reports Bug Patches New Features New Databases","title":"How to Contribute"},{"location":"resources/contributing/#bug-reports","text":"Ensure the bug has not already been reported in our issues . If the bug has not been reported, please feel free to open a new issue . In the new issue, please include a title and clear description of the bug. Also include as much relevant information as possible, a code example that caused the bug, and the error warning .","title":"Bug Reports"},{"location":"resources/contributing/#bug-patches","text":"Open a pull request with the patch. Fully describe the problem the patch is meant to fix. It would also be helpful to link to the relevant issue .","title":"Bug Patches"},{"location":"resources/contributing/#new-features","text":"if you have an idea for new methods to be added to the Lake() class, we would love to hear them! The current state of LakePy mainly deals with accessing the actual lake level data from the disparate data sources that have been collated to our AWS MySQL database. However, it would always be great to give more options and methods to our users. We are sure many of you have great ideas on how this data can be used in ways we never thought of! We currently use issues and PR for bug patches. if you have an idea about a new feature please send a description and code example to lakepygithub@gmail.com . After discussions, revisions, and approval, feel free to open a new pull request with the same title.","title":"New Features"},{"location":"resources/contributing/#new-databases","text":"Adding new lakes to our database is possibly the most helpful thing to this project. We currently source our data from: United States Geological Survey National Water Information System United States Department of Agriculture: Foriegn Agricultural Service's G-REALM Database Theia's HydroWeb Database These are currently some of the largest lake databases, but no database is too big or small for our project! Whether a a new lake data is a country, state, or county, if it is public data, we would love to add it to LakePy. First, please do check to make sure the lakes you wish to add are not already a part of LakePy. Adding a new data source is fairly resource intensive and occurs on our backend. Please reach out to us at lakepygithub@gmail.com to get started on adding a new data source. We appreciate taking the time to look into how to contribute towards LakePy. Thanks, James Gearon & John Franey LakePy is Funded by the Earth Science Information Partners (ESIP) Winter 2020 Grant. See the funded proposal here .","title":"New Databases"}]}